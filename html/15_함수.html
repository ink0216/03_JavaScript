<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title> 15 _ 함수 </title>
</head>
<body>
    <h1>함수(function)</h1>
    <pre>
        - function : 기능
        - 목표하는 결과를 만들기 위한 코드의 묶음
        - 코드를 {} (블록)으로 묶어 작성하고 
            붙여진 이름을 호출해서 사용

        * 함수 선언
        * 함수 정의
        * 함수 호출

        [기본 함수 형태]
        function 함수명(){ 
            //함수 정의
        }

        function 함수명(): 함수 선언부
        onclick 함수명(); : 위에서 정의됐던 함수 호출
    </pre>
    <hr>
    <h1>매개변수(Parameter), 전달 인자(Arguments)</h1>
    <pre>
        * 매개 변수(Parameter)
            - 함수 선언 시 ()안에 작성되는 변수
            -> 함수 호출 시 전달 인자로부터 받은 값을 여기에 저장
            -> 함수 정의 부분에서 사용이 가능해짐

        * 전달 인자(Arguments)
            - 함수 호출 시 ()안에 작성되는 값
            - 함수 매개 변수로 전달되는 값
        
        ex)
        function test(num){}
        test(100)하고 호출하면 100이라는 전달 인자가 
        매개변수로 들어가서 정의 부분에서 사용됨
    </pre>
    <input type="number" id="input1">
    <button id="btn1">확인하기</button>
    버튼 클릭 시 인풋의 값을 얻어와서 함수 수행하기
    <hr>
    <button id="btn2a">매개변수로 배열 전달하기</button>

    <button id="btn2b" onclick="btn2bFn(this)">매개변수로 요소 전달하기</button>
    <!-- onclick : 인라인 이벤트 모델
    HTML 요소에서 this : 이벤트가 발생한 요소 자체를 의미 
    onclick이 click이라는 이벤트를 감지, 버튼 요소 자체가 this가 됨-->
    <button id="btn2c">매개변수로 함수 전달하기</button>
    <hr>
    <hr>
    <hr>
    <h1>return(반환)</h1>
    <pre>
        - 현재 수행중인 함수를 종료하고 호출한 곳으로 돌아감
        -> 함수 호출 구조는 Stack(쌓이다) 형식으로 되어있다!
        -> FILO(First In Last Out, 선입후출) 구조 

        - 호출한 곳으로 돌아갈 때 
            return 옆에 작성된 값을 가지고 돌아갈 수 있다
            옆에 작성된 값이 없으면 그냥 돌아감
            ex) return 100; // 호출한 곳으로 100을 가지고 돌아감
        - 함수 마지막에 return 구문을 쓰지 않았어도
            자동으로 return구문이 추가된다

        1번 함수가 2번 함수 호출하고 
        2번 함수가 3번 함수 호출하고 
        3번 함수가 4번 함수 호출하는 경우
        1번 함수부터 큰 컵 안에 아래부터 쌓임. 다 쌓고나서
        위에서 보면 4번 함수만 보이고 실행됨 나머지는 일시정지됨
        보이는 것만 실행됨 가려진 것은 보이게 될 때까지 일시정지
        4번 함수에서 리턴 구문 만나면 4번 함수는 밖으로 나가서 3번 함수가 보이게 됨
        3번 함수에서 리턴 구문 만나면 3번 함수는 밖으로 나가서 2번 함수가 보이게 됨
        2번 함수에서 리턴 구문 만나면 2번 함수는 밖으로 나가서 1번 함수가 보이게 됨
    </pre>
    매개변수가 들어왔을 때 결과값으로 리턴하기 <br>
    <button id="btn3a">return 확인하기 1</button>
    <hr>
    <hr>
    <hr>
    <h1>익명 함수(이름이 없는 함수)</h1>
    <pre>
        [기본 함수(익명함수 아님)]
        function 함수명([매개변수]){
            //함수 정의
        }
        함수명(); //이름이 있으니까 함수명으로 호출이 가능하다! 
        *************************************************************
        [익명 함수]
        function([매개변수]){
            //함수 정의
        }
        함수 이름이 없어서 호출할 수 없다!!!!! 그럼 어떻게 써먹냐!!!!! 
        *기본 함수와 다르게 
        변수에 대입되거나 매개변수로 바로 전달돼야 하는 곳에 주로 사용됨

        ex) const sumFn = function(a,b){
            return a+b; //이렇게 변수에 대입돼야하는 형태이거나
        }
        ex) 요소.addEventListener("click", function(){}); 이 자리에서 바로 쓰여져야 할 때
    </pre>
    <hr>
    <hr>
    <hr>
    <!-- 요즘 함수 작성 트렌드! 다 이걸로 함 -->
    <h1 style="color: red">화살표 함수(Arrow Function)</h1>
    
    <pre>
    - 익명 함수의 한 종류
    - 익명 함수를 간단히 표기하는 방법 (ES6부터 등장)

    익명 함수 :  function(){}

    1. 기본 형태 :  () => {}

    function(){}
        위아래 둘이 같은 뜻이다! 
    ()=>{}



    <!-- 매개변수 1개면 () 생략 가능!! -->
    2. 매개변수 1개 :  (e) => {}  또는  
                        e  => {}  // 매개변수 하나면 () 생략가능


    3. 매개변수 n개 :  (a,b,c) => {}   //  () 생략 불가


    4. 함수 정의 부분에 return 한 줄만 있을 경우 :

        1) 익명 함수 :               function(){ return 1 + 2; }

        2) 화살표 함수(기본) :       () => { return 1 + 2; }
    
        3) 화살표 함수(return 한줄) : () => 1 + 2
                                    // {return} 생략
                                    오른쪽 파트들이 다 같은 뜻임

    5. 함수 정의 부분에 return 한 줄만 있는데
        return하는 값이 object(객체, 배열 등) 인 경우
        {return} 생략 불가!!!

        () => { return {name:"홍길동", age:20}; }

    </pre>
    <button class="arrow">화살표 함수 기본 형태</button>
    <button class="arrow">매개 변수가 1개인 경우</button>
    <button class="arrow">return 한 줄만 작성된 경우</button>
    <button class="arrow">return 한 줄인데 object를 반환하는 경우</button>
    <hr>
    <h1>즉시 실행 함수</h1>
    <pre>
        (()=>{})() 
        -앞의 괄호 : 함수명
            뒤의 괄호 : 호출
        -익명 함수를 바로 수행하는 함수(1회성으로 이 함수 지금 실행)
        ****즉시 실행 함수를 사용하는 이유****
        -1. 성능(속도)적 우위를 가지기 위해서 사용(이게 아주 약간 빠름)
        -2. 변수명 중복 문제 해결을 위해서 사용됨
        
        const num1=100; // 함수 밖에 쓴 변수 : 어디서든지 쓸 수 있는 전역변수
        (()=>{
            const num1 = 200; //함수 안에 쓴 변수 : 해당 함수 내에서만 효력 있는 지역변수
            이 200값
            console.log(num1); // 하면 200이 출력됨
        })() //변수 이름이 겹치는데 일시적으로 여기서만 다른 값 쓰는 거야! 
    </pre>

    


    <script src="../js/15_함수.js"></script>
</body>
</html>